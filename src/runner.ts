import * as fs from 'fs-extra';
import * as path from 'path';
import { chromium, Browser, Page } from 'playwright';
import * as playwright from 'playwright';
import { Config, TestCase, TestResult, TestStep } from './types';
import { Logger } from './utils/logger';
import { StepTracker } from './utils/step-tracker';
import * as vm from 'vm';
import * as typescript from 'typescript';

export class TestRunner {
  private browser: Browser | null = null;

  constructor(private config: Config) {}

  async runTests(tests: TestCase[]): Promise<TestResult[]> {
    const results: TestResult[] = [];

    // Launch browser
    this.browser = await chromium.launch({ headless: true });

    try {
      // Run tests for live environment
      Logger.dim('  Testing live environment...');
      const liveResults = await this.runTestsForEnvironment(tests, 'live', this.config.liveUrl);
      results.push(...liveResults);

      const livePassed = liveResults.filter(r => r.passed).length;
      const liveFailed = liveResults.filter(r => !r.passed).length;
      Logger.dim(`    ✓ ${livePassed}/${liveResults.length} passed  ✗ ${liveFailed}/${liveResults.length} failed`);

      // Run tests for dev environment
      Logger.dim('  Testing dev environment...');
      const devResults = await this.runTestsForEnvironment(tests, 'dev', this.config.devUrl);
      results.push(...devResults);

      const devPassed = devResults.filter(r => r.passed).length;
      const devFailed = devResults.filter(r => !r.passed).length;
      Logger.dim(`    ✓ ${devPassed}/${devResults.length} passed  ✗ ${devFailed}/${devResults.length} failed`);
    } finally {
      await this.browser?.close();
    }

    return results;
  }

  private async runTestsForEnvironment(
    tests: TestCase[],
    environment: 'live' | 'dev',
    baseUrl: string
  ): Promise<TestResult[]> {
    const results: TestResult[] = [];
    const screenshotsDir = path.join(this.config.outputDir, 'screenshots', environment);
    await fs.ensureDir(screenshotsDir);

    if (this.config.parallel && this.config.maxConcurrency) {
      // Run tests in parallel with concurrency limit
      const chunks = this.chunkArray(tests, this.config.maxConcurrency);

      for (const chunk of chunks) {
        const chunkResults = await Promise.all(
          chunk.map((test) => this.runSingleTest(test, environment, baseUrl, screenshotsDir))
        );
        results.push(...chunkResults);
      }
    } else {
      // Run tests sequentially
      for (const test of tests) {
        const result = await this.runSingleTest(test, environment, baseUrl, screenshotsDir);
        results.push(result);
      }
    }

    return results;
  }

  private async runSingleTest(
    test: TestCase,
    environment: 'live' | 'dev',
    baseUrl: string,
    screenshotsDir: string
  ): Promise<TestResult> {
    const startTime = Date.now();
    const startTimeIso = new Date().toISOString();
    const screenshotPath = path.join(screenshotsDir, `${test.name}.png`);

    // Build the actual URL that will be tested
    const testUrl = this.buildTestUrl(baseUrl, test);

    try {
      if (!this.browser) {
        throw new Error('Browser not initialized');
      }

      const context = await this.browser.newContext({
        viewport: this.config.viewport || { width: 1920, height: 1080 },
      });

      const page = await context.newPage();

      // Run the generated test
      try {
        const detailedResults = await this.executeTest(page, test, baseUrl, screenshotPath);

        await context.close();

        const duration = Date.now() - startTime;
        const endTimeIso = new Date().toISOString();

        // Update timing in detailed results if provided
        if (detailedResults) {
          detailedResults.duration = duration;
          detailedResults.startTime = startTimeIso;
          detailedResults.endTime = endTimeIso;
        }

        // Check if screenshot was created
        const screenshotExists = await fs.pathExists(screenshotPath);

        if (!screenshotExists) {
          // Screenshot missing - run fallback and mark as FAILED
          Logger.warn(`Screenshot missing for ${test.route}, running fallback`);

          const fallbackContext = await this.browser.newContext({
            viewport: this.config.viewport || { width: 1920, height: 1080 },
          });
          const fallbackPage = await fallbackContext.newPage();

          try {
            await this.executeSimpleTest(fallbackPage, test, baseUrl, screenshotPath);
          } finally {
            await fallbackContext.close();
          }

          return {
            route: test.route,
            url: testUrl,
            environment,
            passed: false,
            screenshot: screenshotPath,
            duration,
            error: 'Screenshot not generated by AI test, fallback used',
            detailedResults: detailedResults || {
              testName: test.name,
              status: 'failed',
              duration,
              retries: 0,
              startTime: startTimeIso,
              endTime: endTimeIso,
              error: {
                message: 'Screenshot not generated by AI test',
              },
            },
          };
        }

        // Screenshot exists - test passed
        return {
          route: test.route,
          url: testUrl,
          environment,
          passed: true,
          screenshot: screenshotPath,
          duration,
          detailedResults: detailedResults || {
            testName: test.name,
            status: 'passed',
            duration,
            retries: 0,
            startTime: startTimeIso,
            endTime: endTimeIso,
            steps: [
              { title: 'Navigate to page', duration: duration * 0.6, status: 'passed' },
              { title: 'Wait for load', duration: duration * 0.2, status: 'passed' },
              { title: 'Take screenshot', duration: duration * 0.2, status: 'passed' },
            ],
          },
        };
      } catch (error) {
        await context.close();

        const duration = Date.now() - startTime;
        const endTimeIso = new Date().toISOString();
        Logger.captureError(error as Error, `Test execution failed for ${test.route} (${environment})`);

        // Check if screenshot was created despite the error
        const screenshotExists = await fs.pathExists(screenshotPath);

        if (!screenshotExists) {
          // Screenshot missing - run fallback to get a screenshot
          Logger.warn(`Screenshot missing after error for ${test.route}, running fallback`);

          const fallbackContext = await this.browser.newContext({
            viewport: this.config.viewport || { width: 1920, height: 1080 },
          });
          const fallbackPage = await fallbackContext.newPage();

          try {
            await this.executeSimpleTest(fallbackPage, test, baseUrl, screenshotPath);
          } catch (fallbackError) {
            // Even fallback failed, but we tried
            Logger.warn(`Fallback also failed for ${test.route}`);
          } finally {
            await fallbackContext.close();
          }
        }

        // Return as FAILED (whether fallback ran or not)
        // Include steps if they were captured before the error
        const errorWithSteps = error as Error & { steps?: TestStep[] };
        const steps = errorWithSteps.steps;

        return {
          route: test.route,
          url: testUrl,
          environment,
          passed: false,
          screenshot: screenshotPath,
          duration,
          error: (error as Error).message,
          detailedResults: {
            testName: test.name,
            status: 'failed',
            duration,
            retries: 0,
            startTime: startTimeIso,
            endTime: endTimeIso,
            error: {
              message: (error as Error).message,
              stack: (error as Error).stack,
            },
            steps,
          },
        };
      }
    } catch (error) {
      const duration = Date.now() - startTime;
      const endTimeIso = new Date().toISOString();
      Logger.captureError(error as Error, `Test setup failed for ${test.route} (${environment})`);

      return {
        route: test.route,
        url: testUrl,
        environment,
        passed: false,
        screenshot: screenshotPath,
        duration,
        error: (error as Error).message,
        detailedResults: {
          testName: test.name,
          status: 'failed',
          duration,
          retries: 0,
          startTime: startTimeIso,
          endTime: endTimeIso,
          error: {
            message: (error as Error).message,
            stack: (error as Error).stack,
          },
        },
      };
    }
  }

  private buildTestUrl(baseUrl: string, test: TestCase): string {
    if (test.routerType === 'hash') {
      return baseUrl + '/#' + test.route;
    }
    return baseUrl + test.route;
  }

  private async executeTest(
    page: Page,
    test: TestCase,
    baseUrl: string,
    screenshotPath: string
  ): Promise<TestResult['detailedResults'] | undefined> {
    // Check if we should use AI-generated tests (when testGenerationMode is 'ai')
    if (this.config.testGenerationMode === 'ai' && test.code) {
      // Let AI test run completely - errors will be handled by caller
      return await this.executeAIGeneratedTest(page, test, baseUrl, screenshotPath);
    }

    // Use simple auto-test for template mode or when AI test code is unavailable
    await this.executeSimpleTest(page, test, baseUrl, screenshotPath);
    return undefined;
  }

  private async executeAIGeneratedTest(
    page: Page,
    test: TestCase,
    baseUrl: string,
    screenshotPath: string
  ): Promise<TestResult['detailedResults']> {
    const stepTracker = new StepTracker();

    try {
      // Transpile TypeScript to JavaScript
      const jsCode = typescript.transpileModule(test.code, {
        compilerOptions: {
          module: typescript.ModuleKind.CommonJS,
          target: typescript.ScriptTarget.ES2020,
          esModuleInterop: true,
          allowSyntheticDefaultImports: true,
        },
      }).outputText;

      // Create a sandbox context with necessary imports
      type TestFunction = (
        page: Page,
        baseUrl: string,
        screenshotPath: string,
        stepLogger: { log: (message: string) => void }
      ) => Promise<void>;

      interface SandboxModule {
        exports: { test?: TestFunction };
      }

      interface SandboxContext {
        page: Page;
        baseUrl: string;
        screenshotPath: string;
        console: typeof console;
        stepLogger: { log: (message: string) => void };
        require: (moduleName: string) => unknown;
        exports: { test?: TestFunction };
        module: SandboxModule;
      }

      const sandbox: SandboxContext = {
        page,
        baseUrl,
        screenshotPath,
        console,
        stepLogger: {
          log: (message: string) => stepTracker.log(message),
        },
        require: (moduleName: string) => {
          // Allow Playwright imports - return the full playwright module
          if (moduleName === '@playwright/test' || moduleName === 'playwright') {
            return playwright;
          }
          // Allow Node.js built-in modules
          if (moduleName === 'path') {
            return path;
          }
          if (moduleName === 'fs' || moduleName === 'fs-extra') {
            return fs;
          }
          // For any other module, try to require it from the actual environment
          try {
            return require(moduleName);
          } catch {
            throw new Error(`Module ${moduleName} is not available in test sandbox`);
          }
        },
        exports: {},
        module: { exports: {} },
      };

      // Create VM context
      const context = vm.createContext(sandbox);

      // Execute the transpiled code
      vm.runInContext(jsCode, context);

      // Get the exported test function
      const testFunction = sandbox.module.exports.test || sandbox.exports.test;

      if (typeof testFunction !== 'function') {
        throw new Error('AI-generated test does not export a "test" function');
      }

      // Execute the test function with timeout
      const testTimeout = 60000; // 60 seconds total for AI test
      await Promise.race([
        testFunction(page, baseUrl, screenshotPath, sandbox.stepLogger),
        new Promise((_, reject) =>
          setTimeout(() => reject(new Error('AI test execution timeout (60s)')), testTimeout)
        ),
      ]);

      // Get captured steps and mark them as passed
      const steps = stepTracker.getSteps().map(step => ({
        ...step,
        status: (step.error ? 'failed' : 'passed') as 'passed' | 'failed',
      }));

      return {
        testName: test.name,
        status: 'passed',
        duration: 0, // Will be set by caller
        retries: 0,
        startTime: '', // Will be set by caller
        endTime: '', // Will be set by caller
        steps,
      };

    } catch (error) {
      const errorMessage = (error as Error).message;

      // Mark current step as failed
      stepTracker.markCurrentStepFailed(errorMessage);

      // Get captured steps
      const steps = stepTracker.getSteps().map(step => ({
        ...step,
        status: (step.error ? 'failed' : 'passed') as 'passed' | 'failed',
      }));

      // Check if it's a timeout or selector error
      if (errorMessage.includes('Timeout') || errorMessage.includes('waiting for')) {
        Logger.warn(`AI test timeout for ${test.route}: ${errorMessage.split('\n')[0]}`);
      } else {
        Logger.captureError(error as Error, `AI test failed for ${test.route}`);
      }

      // Re-throw error with steps - caller will check for screenshot and handle fallback
      const detailedError = error as Error & { steps?: TestStep[] };
      detailedError.steps = steps;
      throw detailedError;
    }
  }

  private async executeSimpleTest(
    page: Page,
    test: TestCase,
    baseUrl: string,
    screenshotPath: string
  ): Promise<void> {
    try {
      // Navigate to the page
      const url = this.buildTestUrl(baseUrl, test);
      await page.goto(url, { waitUntil: 'networkidle', timeout: 30000 });

      // Wait for page to be fully loaded
      await page.waitForLoadState('domcontentloaded');

      // Take screenshot
      await page.screenshot({
        path: screenshotPath,
        fullPage: true,
      });
    } catch (error) {
      // Try to take a screenshot even on error
      try {
        await page.screenshot({
          path: screenshotPath,
          fullPage: true,
        });
      } catch {
        // Ignore screenshot errors
      }

      throw error;
    }
  }

  private chunkArray<T>(array: T[], size: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  }
}
